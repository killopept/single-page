{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../../node_modules/custom-event/index.js","webpack:///../../src/applications/app-errors.js","webpack:///../../src/applications/app.helpers.js","webpack:///../../src/applications/timeouts.js","webpack:///../../src/utils/find.js","webpack:///../../src/lifecycles/lifecycle.helpers.js","webpack:///../../src/lifecycles/bootstrap.js","webpack:///../../src/lifecycles/unmount.js","webpack:///../../src/lifecycles/mount.js","webpack:///../../src/parcels/mount-parcel.js","webpack:///../../src/lifecycles/update.js","webpack:///../../src/lifecycles/prop.helpers.js","webpack:///../../src/lifecycles/load.js","webpack:///../../src/navigation/navigation-events.js","webpack:///../../src/jquery-support.js","webpack:///../../src/lifecycles/unload.js","webpack:///../../src/applications/apps.js","webpack:///../../src/navigation/reroute.js","webpack:///../../src/start.js","webpack:///../../src/devtools/devtools.js","webpack:///../../src/single-spa.js","webpack:///(webpack)/buildin/global.js","webpack:///./single-spa.config.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","parentHotUpdateCallback","window","hotAvailableFilesMap","hotRequestedFilesMap","hotUpdate","hotWaitingFiles","hotChunksLoading","hotUpdateDownloaded","hotAddUpdateChunk","hotCurrentChildModule","hotApplyOnUpdate","hotCurrentHash","hotRequestTimeout","hotCurrentModuleData","hotCurrentParents","hotCurrentParentsTemp","hotCreateRequire","me","installedModules","__webpack_require__","fn","request","hot","active","parents","indexOf","children","console","warn","ObjectFactory","name","configurable","enumerable","get","set","value","defineProperty","e","hotStatus","hotSetStatus","then","finishChunkLoading","err","hotWaitingFilesMap","hotEnsureUpdateChunk","t","mode","hotCreateModule","_acceptedDependencies","_declinedDependencies","_selfAccepted","_selfDeclined","_disposeHandlers","_main","accept","dep","callback","undefined","decline","dispose","addDisposeHandler","removeDisposeHandler","idx","splice","check","hotCheck","apply","hotApply","status","l","hotStatusHandlers","addStatusHandler","removeStatusHandler","newStatus","hotDeferred","hotUpdateNewHash","toModuleId","id","Error","requestTimeout","Promise","resolve","reject","XMLHttpRequest","requestPath","p","open","timeout","send","onreadystatechange","readyState","update","JSON","parse","responseText","c","h","promise","script","document","createElement","charset","src","head","appendChild","hotDownloadUpdateChunk","deferred","result","outdatedModules","options","cb","j","module","getAffectedStuff","updateModuleId","outdatedDependencies","queue","map","chain","queueItem","pop","type","parentId","parent","concat","addAllToSet","a","b","item","appliedUpdate","warnUnexpectedRequire","abortError","doApply","doDispose","chainInfo","join","onDeclined","ignoreDeclined","onUnaccepted","ignoreUnaccepted","onAccepted","onDisposed","outdatedSelfAcceptedModules","errorHandler","keys","forEach","hotDisposeChunk","dependency","moduleOutdatedDependencies","slice","disposeHandlers","child","error","callbacks","onErrored","dependencyId","ignoreErrored","err2","originalError","1","exports","promises","installedChunkData","onScriptComplete","nc","setAttribute","jsonpScriptSrc","event","onerror","onload","clearTimeout","chunk","errorType","realSrc","target","message","setTimeout","all","m","d","getter","o","r","Symbol","toStringTag","__esModule","ns","create","key","bind","n","object","property","oe","jsonpArray","oldJsonpFunction","s","NativeCustomEvent","CustomEvent","detail","foo","createEvent","params","initCustomEvent","bubbles","cancelable","createEventObject","Boolean","errorHandlers","handleAppError","app","transformedErr","transformErr","handler","addErrorHandler","removeErrorHandler","removedSomething","filter","isHandler","ogErr","appOrParcel","objectType","unmountThisParcel","errPrefix","stringify","appName","NOT_LOADED","LOADING_SOURCE_CODE","NOT_BOOTSTRAPPED","BOOTSTRAPPING","NOT_MOUNTED","MOUNTING","MOUNTED","UPDATING","UNMOUNTING","UNLOADING","SKIP_BECAUSE_BROKEN","isActive","isntActive","isLoaded","isntLoaded","shouldBeActive","activeWhen","location","shouldntBeActive","notSkipped","toName","globalTimeoutConfig","bootstrap","millis","dieOnTimeout","mount","unmount","unload","setBootstrapMaxTime","time","setMountMaxTime","setUnmountMaxTime","setUnloadMaxTime","reasonableTime","description","timeoutConfig","warningPeriod","finished","errored","maybeTimingOut","shouldError","numWarnings","numMillis","val","catch","ensureValidAppTimeouts","timeouts","find","arr","func","validLifecycleFn","Array","isArray","flattenFnArray","fns","props","waitForPromises","index","smellsLikeAPromise","toBootstrapPromise","hardFail","getProps","toUnmountPromise","unmountChildrenParcels","parcels","parcelId","unmountAppOrParcel","parentError","parcelError","beforeFirstMountFired","firstMountFired","toMountPromise","dispatchEvent","setSkipBecauseBroken","parcelCount","rootParcels","mountRootParcel","mountParcel","arguments","config","customProps","owningAppOrParcel","this","_typeof","domElement","externalRepresentation","passedConfigLoadingFunction","configLoadingFunction","parcel","parentName","resolveUnmount","rejectUnmount","loadPromise","bootstrapPromise","promiseWithoutReturnValue","mountPromise","unmountPromise","getStatus","singleSpa","unmountSelf","toLoadPromise","loadImpl","validationErrMessage","appOpts","devtools","overlays","capturedEventListeners","hashchange","popstate","routingEventsListeningTo","navigateToUrl","obj","url","opts","href","currentTarget","preventDefault","current","parseUri","destination","hash","anchor","host","isTestingEnv","wouldHaveReloadedThePage","path","history","pushState","callCapturedEventListeners","eventArguments","eventType","listener","_this","urlReroute","reroute","addEventListener","originalAddEventListener","originalRemoveEventListener","removeEventListener","eventName","listenerFn","originalPushState","state","createPopStateEvent","originalReplaceState","replaceState","PopStateEvent","evt","initPopStateEvent","str","strictMode","q","parser","strict","loose","exec","uri","replace","$0","$1","$2","singleSpaNavigate","hasInitialized","ensureJQuerySupport","jQuery","$","jquery","originalJQueryOn","on","originalJQueryOff","off","eventString","captureRoutingEvents","originalJQueryFunction","nativeFunctionToCall","originalArgs","split","trim","appsToUnload","toUnloadPromise","unloadInfo","finishUnloadingApp","addAppToUnload","promiseGetter","apps","getMountedApps","getAppNames","getAppStatus","declareChildApplication","arg1","arg2","registerApplication","applicationOrLoadingFn","activityFn","selectors","checkActivityFunctions","activeApps","getAppsToLoad","unloadChildApplication","unloadApplication","waitForUnmount","App","resultPromise","appUnloadInfo","immediatelyUnloadApp","appChangeUnderway","peopleWaitingOnAppChange","triggerAppChange","pendingPromises","wasNoOp","started","getCustomEventDetail","unloadPromises","allUnmountPromises","unmountAllPromise","appsToLoad","loadThenMountPromises","mountPromises","appToMount","callAllEventListeners","finishUpAndReturn","loadPromises","callEventListeners","returnValue","appChangeEventName","nextPendingPromises","pendingPromise","originalEvent","start","It","getRawAppData","unregisterApplication","appIndex","findIndex","__SINGLE_SPA_DEVTOOLS__","exposedMethods","g","Function","__webpack_exports__","single_spa__WEBPACK_IMPORTED_MODULE_0__","pathPrefix","prefix","pathname"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n \tfunction hotDisposeChunk(chunkId) {\n \t\tdelete installedChunks[chunkId];\n \t}\n \tvar parentHotUpdateCallback = window[\"webpackHotUpdate\"];\n \twindow[\"webpackHotUpdate\"] = // eslint-disable-next-line no-unused-vars\n \tfunction webpackHotUpdateCallback(chunkId, moreModules) {\n \t\thotAddUpdateChunk(chunkId, moreModules);\n \t\tif (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\n \t} ;\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadUpdateChunk(chunkId) {\n \t\tvar script = document.createElement(\"script\");\n \t\tscript.charset = \"utf-8\";\n \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\";\n \t\tif (null) script.crossOrigin = null;\n \t\tdocument.head.appendChild(script);\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadManifest(requestTimeout) {\n \t\trequestTimeout = requestTimeout || 10000;\n \t\treturn new Promise(function(resolve, reject) {\n \t\t\tif (typeof XMLHttpRequest === \"undefined\") {\n \t\t\t\treturn reject(new Error(\"No browser support\"));\n \t\t\t}\n \t\t\ttry {\n \t\t\t\tvar request = new XMLHttpRequest();\n \t\t\t\tvar requestPath = __webpack_require__.p + \"\" + hotCurrentHash + \".hot-update.json\";\n \t\t\t\trequest.open(\"GET\", requestPath, true);\n \t\t\t\trequest.timeout = requestTimeout;\n \t\t\t\trequest.send(null);\n \t\t\t} catch (err) {\n \t\t\t\treturn reject(err);\n \t\t\t}\n \t\t\trequest.onreadystatechange = function() {\n \t\t\t\tif (request.readyState !== 4) return;\n \t\t\t\tif (request.status === 0) {\n \t\t\t\t\t// timeout\n \t\t\t\t\treject(\n \t\t\t\t\t\tnew Error(\"Manifest request to \" + requestPath + \" timed out.\")\n \t\t\t\t\t);\n \t\t\t\t} else if (request.status === 404) {\n \t\t\t\t\t// no update available\n \t\t\t\t\tresolve();\n \t\t\t\t} else if (request.status !== 200 && request.status !== 304) {\n \t\t\t\t\t// other failure\n \t\t\t\t\treject(new Error(\"Manifest request to \" + requestPath + \" failed.\"));\n \t\t\t\t} else {\n \t\t\t\t\t// success\n \t\t\t\t\ttry {\n \t\t\t\t\t\tvar update = JSON.parse(request.responseText);\n \t\t\t\t\t} catch (e) {\n \t\t\t\t\t\treject(e);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\tresolve(update);\n \t\t\t\t}\n \t\t\t};\n \t\t});\n \t}\n\n \tvar hotApplyOnUpdate = true;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentHash = \"3fbac17e194167ccd1ee\";\n \tvar hotRequestTimeout = 10000;\n \tvar hotCurrentModuleData = {};\n \tvar hotCurrentChildModule;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParents = [];\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParentsTemp = [];\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateRequire(moduleId) {\n \t\tvar me = installedModules[moduleId];\n \t\tif (!me) return __webpack_require__;\n \t\tvar fn = function(request) {\n \t\t\tif (me.hot.active) {\n \t\t\t\tif (installedModules[request]) {\n \t\t\t\t\tif (installedModules[request].parents.indexOf(moduleId) === -1) {\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\thotCurrentParents = [moduleId];\n \t\t\t\t\thotCurrentChildModule = request;\n \t\t\t\t}\n \t\t\t\tif (me.children.indexOf(request) === -1) {\n \t\t\t\t\tme.children.push(request);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tconsole.warn(\n \t\t\t\t\t\"[HMR] unexpected require(\" +\n \t\t\t\t\t\trequest +\n \t\t\t\t\t\t\") from disposed module \" +\n \t\t\t\t\t\tmoduleId\n \t\t\t\t);\n \t\t\t\thotCurrentParents = [];\n \t\t\t}\n \t\t\treturn __webpack_require__(request);\n \t\t};\n \t\tvar ObjectFactory = function ObjectFactory(name) {\n \t\t\treturn {\n \t\t\t\tconfigurable: true,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: function() {\n \t\t\t\t\treturn __webpack_require__[name];\n \t\t\t\t},\n \t\t\t\tset: function(value) {\n \t\t\t\t\t__webpack_require__[name] = value;\n \t\t\t\t}\n \t\t\t};\n \t\t};\n \t\tfor (var name in __webpack_require__) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(__webpack_require__, name) &&\n \t\t\t\tname !== \"e\" &&\n \t\t\t\tname !== \"t\"\n \t\t\t) {\n \t\t\t\tObject.defineProperty(fn, name, ObjectFactory(name));\n \t\t\t}\n \t\t}\n \t\tfn.e = function(chunkId) {\n \t\t\tif (hotStatus === \"ready\") hotSetStatus(\"prepare\");\n \t\t\thotChunksLoading++;\n \t\t\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\n \t\t\t\tfinishChunkLoading();\n \t\t\t\tthrow err;\n \t\t\t});\n\n \t\t\tfunction finishChunkLoading() {\n \t\t\t\thotChunksLoading--;\n \t\t\t\tif (hotStatus === \"prepare\") {\n \t\t\t\t\tif (!hotWaitingFilesMap[chunkId]) {\n \t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t\t\t}\n \t\t\t\t\tif (hotChunksLoading === 0 && hotWaitingFiles === 0) {\n \t\t\t\t\t\thotUpdateDownloaded();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t\tfn.t = function(value, mode) {\n \t\t\tif (mode & 1) value = fn(value);\n \t\t\treturn __webpack_require__.t(value, mode & ~1);\n \t\t};\n \t\treturn fn;\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateModule(moduleId) {\n \t\tvar hot = {\n \t\t\t// private stuff\n \t\t\t_acceptedDependencies: {},\n \t\t\t_declinedDependencies: {},\n \t\t\t_selfAccepted: false,\n \t\t\t_selfDeclined: false,\n \t\t\t_disposeHandlers: [],\n \t\t\t_main: hotCurrentChildModule !== moduleId,\n\n \t\t\t// Module API\n \t\t\tactive: true,\n \t\t\taccept: function(dep, callback) {\n \t\t\t\tif (dep === undefined) hot._selfAccepted = true;\n \t\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\n \t\t\t\telse hot._acceptedDependencies[dep] = callback || function() {};\n \t\t\t},\n \t\t\tdecline: function(dep) {\n \t\t\t\tif (dep === undefined) hot._selfDeclined = true;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n \t\t\t\telse hot._declinedDependencies[dep] = true;\n \t\t\t},\n \t\t\tdispose: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\taddDisposeHandler: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\tremoveDisposeHandler: function(callback) {\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n \t\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t// Management API\n \t\t\tcheck: hotCheck,\n \t\t\tapply: hotApply,\n \t\t\tstatus: function(l) {\n \t\t\t\tif (!l) return hotStatus;\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\taddStatusHandler: function(l) {\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\tremoveStatusHandler: function(l) {\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\n \t\t\t\tif (idx >= 0) hotStatusHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t//inherit from previous dispose call\n \t\t\tdata: hotCurrentModuleData[moduleId]\n \t\t};\n \t\thotCurrentChildModule = undefined;\n \t\treturn hot;\n \t}\n\n \tvar hotStatusHandlers = [];\n \tvar hotStatus = \"idle\";\n\n \tfunction hotSetStatus(newStatus) {\n \t\thotStatus = newStatus;\n \t\tfor (var i = 0; i < hotStatusHandlers.length; i++)\n \t\t\thotStatusHandlers[i].call(null, newStatus);\n \t}\n\n \t// while downloading\n \tvar hotWaitingFiles = 0;\n \tvar hotChunksLoading = 0;\n \tvar hotWaitingFilesMap = {};\n \tvar hotRequestedFilesMap = {};\n \tvar hotAvailableFilesMap = {};\n \tvar hotDeferred;\n\n \t// The update info\n \tvar hotUpdate, hotUpdateNewHash;\n\n \tfunction toModuleId(id) {\n \t\tvar isNumber = +id + \"\" === id;\n \t\treturn isNumber ? +id : id;\n \t}\n\n \tfunction hotCheck(apply) {\n \t\tif (hotStatus !== \"idle\") {\n \t\t\tthrow new Error(\"check() is only allowed in idle status\");\n \t\t}\n \t\thotApplyOnUpdate = apply;\n \t\thotSetStatus(\"check\");\n \t\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\n \t\t\tif (!update) {\n \t\t\t\thotSetStatus(\"idle\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\thotRequestedFilesMap = {};\n \t\t\thotWaitingFilesMap = {};\n \t\t\thotAvailableFilesMap = update.c;\n \t\t\thotUpdateNewHash = update.h;\n\n \t\t\thotSetStatus(\"prepare\");\n \t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\thotDeferred = {\n \t\t\t\t\tresolve: resolve,\n \t\t\t\t\treject: reject\n \t\t\t\t};\n \t\t\t});\n \t\t\thotUpdate = {};\n \t\t\tfor(var chunkId in installedChunks)\n \t\t\t// eslint-disable-next-line no-lone-blocks\n \t\t\t{\n \t\t\t\t/*globals chunkId */\n \t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t}\n \t\t\tif (\n \t\t\t\thotStatus === \"prepare\" &&\n \t\t\t\thotChunksLoading === 0 &&\n \t\t\t\thotWaitingFiles === 0\n \t\t\t) {\n \t\t\t\thotUpdateDownloaded();\n \t\t\t}\n \t\t\treturn promise;\n \t\t});\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotAddUpdateChunk(chunkId, moreModules) {\n \t\tif (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\n \t\t\treturn;\n \t\thotRequestedFilesMap[chunkId] = false;\n \t\tfor (var moduleId in moreModules) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\n \t\t\thotUpdateDownloaded();\n \t\t}\n \t}\n\n \tfunction hotEnsureUpdateChunk(chunkId) {\n \t\tif (!hotAvailableFilesMap[chunkId]) {\n \t\t\thotWaitingFilesMap[chunkId] = true;\n \t\t} else {\n \t\t\thotRequestedFilesMap[chunkId] = true;\n \t\t\thotWaitingFiles++;\n \t\t\thotDownloadUpdateChunk(chunkId);\n \t\t}\n \t}\n\n \tfunction hotUpdateDownloaded() {\n \t\thotSetStatus(\"ready\");\n \t\tvar deferred = hotDeferred;\n \t\thotDeferred = null;\n \t\tif (!deferred) return;\n \t\tif (hotApplyOnUpdate) {\n \t\t\t// Wrap deferred object in Promise to mark it as a well-handled Promise to\n \t\t\t// avoid triggering uncaught exception warning in Chrome.\n \t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\n \t\t\tPromise.resolve()\n \t\t\t\t.then(function() {\n \t\t\t\t\treturn hotApply(hotApplyOnUpdate);\n \t\t\t\t})\n \t\t\t\t.then(\n \t\t\t\t\tfunction(result) {\n \t\t\t\t\t\tdeferred.resolve(result);\n \t\t\t\t\t},\n \t\t\t\t\tfunction(err) {\n \t\t\t\t\t\tdeferred.reject(err);\n \t\t\t\t\t}\n \t\t\t\t);\n \t\t} else {\n \t\t\tvar outdatedModules = [];\n \t\t\tfor (var id in hotUpdate) {\n \t\t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\n \t\t\t\t}\n \t\t\t}\n \t\t\tdeferred.resolve(outdatedModules);\n \t\t}\n \t}\n\n \tfunction hotApply(options) {\n \t\tif (hotStatus !== \"ready\")\n \t\t\tthrow new Error(\"apply() is only allowed in ready status\");\n \t\toptions = options || {};\n\n \t\tvar cb;\n \t\tvar i;\n \t\tvar j;\n \t\tvar module;\n \t\tvar moduleId;\n\n \t\tfunction getAffectedStuff(updateModuleId) {\n \t\t\tvar outdatedModules = [updateModuleId];\n \t\t\tvar outdatedDependencies = {};\n\n \t\t\tvar queue = outdatedModules.map(function(id) {\n \t\t\t\treturn {\n \t\t\t\t\tchain: [id],\n \t\t\t\t\tid: id\n \t\t\t\t};\n \t\t\t});\n \t\t\twhile (queue.length > 0) {\n \t\t\t\tvar queueItem = queue.pop();\n \t\t\t\tvar moduleId = queueItem.id;\n \t\t\t\tvar chain = queueItem.chain;\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (!module || module.hot._selfAccepted) continue;\n \t\t\t\tif (module.hot._selfDeclined) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"self-declined\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tif (module.hot._main) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"unaccepted\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n \t\t\t\t\tvar parentId = module.parents[i];\n \t\t\t\t\tvar parent = installedModules[parentId];\n \t\t\t\t\tif (!parent) continue;\n \t\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n \t\t\t\t\t\treturn {\n \t\t\t\t\t\t\ttype: \"declined\",\n \t\t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\tparentId: parentId\n \t\t\t\t\t\t};\n \t\t\t\t\t}\n \t\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n \t\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n \t\t\t\t\t\tif (!outdatedDependencies[parentId])\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tdelete outdatedDependencies[parentId];\n \t\t\t\t\toutdatedModules.push(parentId);\n \t\t\t\t\tqueue.push({\n \t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\tid: parentId\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t}\n\n \t\t\treturn {\n \t\t\t\ttype: \"accepted\",\n \t\t\t\tmoduleId: updateModuleId,\n \t\t\t\toutdatedModules: outdatedModules,\n \t\t\t\toutdatedDependencies: outdatedDependencies\n \t\t\t};\n \t\t}\n\n \t\tfunction addAllToSet(a, b) {\n \t\t\tfor (var i = 0; i < b.length; i++) {\n \t\t\t\tvar item = b[i];\n \t\t\t\tif (a.indexOf(item) === -1) a.push(item);\n \t\t\t}\n \t\t}\n\n \t\t// at begin all updates modules are outdated\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\n \t\tvar outdatedDependencies = {};\n \t\tvar outdatedModules = [];\n \t\tvar appliedUpdate = {};\n\n \t\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\n \t\t\tconsole.warn(\n \t\t\t\t\"[HMR] unexpected require(\" + result.moduleId + \") to disposed module\"\n \t\t\t);\n \t\t};\n\n \t\tfor (var id in hotUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\tmoduleId = toModuleId(id);\n \t\t\t\t/** @type {TODO} */\n \t\t\t\tvar result;\n \t\t\t\tif (hotUpdate[id]) {\n \t\t\t\t\tresult = getAffectedStuff(moduleId);\n \t\t\t\t} else {\n \t\t\t\t\tresult = {\n \t\t\t\t\t\ttype: \"disposed\",\n \t\t\t\t\t\tmoduleId: id\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\t/** @type {Error|false} */\n \t\t\t\tvar abortError = false;\n \t\t\t\tvar doApply = false;\n \t\t\t\tvar doDispose = false;\n \t\t\t\tvar chainInfo = \"\";\n \t\t\t\tif (result.chain) {\n \t\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n \t\t\t\t}\n \t\t\t\tswitch (result.type) {\n \t\t\t\t\tcase \"self-declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\t\" in \" +\n \t\t\t\t\t\t\t\t\tresult.parentId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"unaccepted\":\n \t\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n \t\t\t\t\t\tif (!options.ignoreUnaccepted)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"accepted\":\n \t\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n \t\t\t\t\t\tdoApply = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"disposed\":\n \t\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n \t\t\t\t\t\tdoDispose = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n \t\t\t\t}\n \t\t\t\tif (abortError) {\n \t\t\t\t\thotSetStatus(\"abort\");\n \t\t\t\t\treturn Promise.reject(abortError);\n \t\t\t\t}\n \t\t\t\tif (doApply) {\n \t\t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\n \t\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n \t\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n \t\t\t\t\t\tif (\n \t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(\n \t\t\t\t\t\t\t\tresult.outdatedDependencies,\n \t\t\t\t\t\t\t\tmoduleId\n \t\t\t\t\t\t\t)\n \t\t\t\t\t\t) {\n \t\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n \t\t\t\t\t\t\taddAllToSet(\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n \t\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (doDispose) {\n \t\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n \t\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Store self accepted outdated modules to require them later by the module system\n \t\tvar outdatedSelfAcceptedModules = [];\n \t\tfor (i = 0; i < outdatedModules.length; i++) {\n \t\t\tmoduleId = outdatedModules[i];\n \t\t\tif (\n \t\t\t\tinstalledModules[moduleId] &&\n \t\t\t\tinstalledModules[moduleId].hot._selfAccepted &&\n \t\t\t\t// removed self-accepted modules should not be required\n \t\t\t\tappliedUpdate[moduleId] !== warnUnexpectedRequire\n \t\t\t) {\n \t\t\t\toutdatedSelfAcceptedModules.push({\n \t\t\t\t\tmodule: moduleId,\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\n \t\t\t\t});\n \t\t\t}\n \t\t}\n\n \t\t// Now in \"dispose\" phase\n \t\thotSetStatus(\"dispose\");\n \t\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\n \t\t\tif (hotAvailableFilesMap[chunkId] === false) {\n \t\t\t\thotDisposeChunk(chunkId);\n \t\t\t}\n \t\t});\n\n \t\tvar idx;\n \t\tvar queue = outdatedModules.slice();\n \t\twhile (queue.length > 0) {\n \t\t\tmoduleId = queue.pop();\n \t\t\tmodule = installedModules[moduleId];\n \t\t\tif (!module) continue;\n\n \t\t\tvar data = {};\n\n \t\t\t// Call dispose handlers\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n \t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n \t\t\t\tcb = disposeHandlers[j];\n \t\t\t\tcb(data);\n \t\t\t}\n \t\t\thotCurrentModuleData[moduleId] = data;\n\n \t\t\t// disable module (this disables requires from this module)\n \t\t\tmodule.hot.active = false;\n\n \t\t\t// remove module from cache\n \t\t\tdelete installedModules[moduleId];\n\n \t\t\t// when disposing there is no need to call dispose handler\n \t\t\tdelete outdatedDependencies[moduleId];\n\n \t\t\t// remove \"parents\" references from all children\n \t\t\tfor (j = 0; j < module.children.length; j++) {\n \t\t\t\tvar child = installedModules[module.children[j]];\n \t\t\t\tif (!child) continue;\n \t\t\t\tidx = child.parents.indexOf(moduleId);\n \t\t\t\tif (idx >= 0) {\n \t\t\t\t\tchild.parents.splice(idx, 1);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// remove outdated dependency from module children\n \t\tvar dependency;\n \t\tvar moduleOutdatedDependencies;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n \t\t\t\t\t\tidx = module.children.indexOf(dependency);\n \t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Now in \"apply\" phase\n \t\thotSetStatus(\"apply\");\n\n \t\thotCurrentHash = hotUpdateNewHash;\n\n \t\t// insert new code\n \t\tfor (moduleId in appliedUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\n \t\t\t}\n \t\t}\n\n \t\t// call accept handlers\n \t\tvar error = null;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tvar callbacks = [];\n \t\t\t\t\tfor (i = 0; i < moduleOutdatedDependencies.length; i++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[i];\n \t\t\t\t\t\tcb = module.hot._acceptedDependencies[dependency];\n \t\t\t\t\t\tif (cb) {\n \t\t\t\t\t\t\tif (callbacks.indexOf(cb) !== -1) continue;\n \t\t\t\t\t\t\tcallbacks.push(cb);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfor (i = 0; i < callbacks.length; i++) {\n \t\t\t\t\t\tcb = callbacks[i];\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tcb(moduleOutdatedDependencies);\n \t\t\t\t\t\t} catch (err) {\n \t\t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n \t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\t\tdependencyId: moduleOutdatedDependencies[i],\n \t\t\t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Load self accepted modules\n \t\tfor (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\n \t\t\tmoduleId = item.module;\n \t\t\thotCurrentParents = [moduleId];\n \t\t\ttry {\n \t\t\t\t__webpack_require__(moduleId);\n \t\t\t} catch (err) {\n \t\t\t\tif (typeof item.errorHandler === \"function\") {\n \t\t\t\t\ttry {\n \t\t\t\t\t\titem.errorHandler(err);\n \t\t\t\t\t} catch (err2) {\n \t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n \t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\terror: err2,\n \t\t\t\t\t\t\t\toriginalError: err\n \t\t\t\t\t\t\t});\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\tif (!error) error = err2;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\ttype: \"self-accept-errored\",\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// handle errors in accept handlers and self accepted module load\n \t\tif (error) {\n \t\t\thotSetStatus(\"fail\");\n \t\t\treturn Promise.reject(error);\n \t\t}\n\n \t\thotSetStatus(\"idle\");\n \t\treturn new Promise(function(resolve) {\n \t\t\tresolve(outdatedModules);\n \t\t});\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t1: 0\n \t};\n\n\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + ({}[chunkId]||chunkId) + \".bundle.js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {},\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(\"./single-spa.config.js\")(__webpack_require__.s = \"./single-spa.config.js\");\n","\nvar NativeCustomEvent = global.CustomEvent;\n\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n","let errorHandlers = []\n\nexport function handleAppError(err, app) {\n  const transformedErr = transformErr(err, app);\n\n  if (errorHandlers.length) {\n    errorHandlers.forEach(handler => handler(transformedErr));\n  } else {\n    setTimeout(() => {\n      throw transformedErr;\n    });\n  }\n}\n\nexport function addErrorHandler(handler) {\n  if (typeof handler !== 'function') {\n    throw Error('a single-spa error handler must be a function');\n  }\n\n  errorHandlers.push(handler);\n}\n\nexport function removeErrorHandler(handler) {\n  if (typeof handler !== 'function') {\n    throw Error('a single-spa error handler must be a function');\n  }\n\n  let removedSomething = false;\n  errorHandlers = errorHandlers.filter(h => {\n    const isHandler = h === handler;\n    removedSomething = removedSomething || isHandler;\n    return !isHandler;\n  })\n\n  return removedSomething;\n}\n\nexport function transformErr(ogErr, appOrParcel) {\n  const objectType = appOrParcel.unmountThisParcel ? 'Parcel' : 'Application';\n  const errPrefix = `${objectType} '${appOrParcel.name}' died in status ${appOrParcel.status}: `;\n\n  let result;\n\n  if (ogErr instanceof Error) {\n    try {\n      ogErr.message = errPrefix + ogErr.message;\n    } catch(err) {\n      /* Some errors have read-only message properties, in which case there is nothing\n       * that we can do.\n       */\n    }\n    result = ogErr;\n  } else {\n    console.warn(`While ${appOrParcel.status}, '${appOrParcel.name}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`);\n    try {\n      result = Error(errPrefix + JSON.stringify(ogErr));\n    } catch(err) {\n      // If it's not an Error and you can't stringify it, then what else can you even do to it?\n      result = ogErr;\n    }\n  }\n\n  result.appName = appOrParcel.name;\n  result.name = appOrParcel.name\n\n  return result;\n}\n","import { handleAppError } from './app-errors.js';\n\n// App statuses\nexport const NOT_LOADED = 'NOT_LOADED';\nexport const LOADING_SOURCE_CODE = 'LOADING_SOURCE_CODE';\nexport const NOT_BOOTSTRAPPED = 'NOT_BOOTSTRAPPED';\nexport const BOOTSTRAPPING = 'BOOTSTRAPPING';\nexport const NOT_MOUNTED = 'NOT_MOUNTED';\nexport const MOUNTING = 'MOUNTING';\nexport const MOUNTED = 'MOUNTED';\nexport const UPDATING = 'UPDATING';\nexport const UNMOUNTING = 'UNMOUNTING';\nexport const UNLOADING = 'UNLOADING';\nexport const SKIP_BECAUSE_BROKEN = 'SKIP_BECAUSE_BROKEN';\n\nexport function isActive(app) {\n  return app.status === MOUNTED;\n}\n\nexport function isntActive(app) {\n  return !isActive(app);\n}\n\nexport function isLoaded(app) {\n  return app.status !== NOT_LOADED && app.status !== LOADING_SOURCE_CODE;\n}\n\nexport function isntLoaded(app) {\n  return !isLoaded(app);\n}\n\nexport function shouldBeActive(app) {\n  try {\n    return app.activeWhen(window.location);\n  } catch (err) {\n    handleAppError(err, app);\n    app.status = SKIP_BECAUSE_BROKEN;\n  }\n}\n\nexport function shouldntBeActive(app) {\n  try {\n    return !app.activeWhen(window.location);\n  } catch (err) {\n    handleAppError(err, app);\n    app.status = SKIP_BECAUSE_BROKEN;\n  }\n}\n\nexport function notBootstrapped(app) {\n  return app.status !== NOT_BOOTSTRAPPED;\n}\n\nexport function notSkipped(item) {\n  return item !== SKIP_BECAUSE_BROKEN && (!item || item.status !== SKIP_BECAUSE_BROKEN);\n}\n\nexport function toName(app) {\n  return app.name;\n}\n","const globalTimeoutConfig = {\n  bootstrap: {\n    millis: 4000,\n    dieOnTimeout: false,\n  },\n  mount: {\n    millis: 3000,\n    dieOnTimeout: false,\n  },\n  unmount: {\n    millis: 3000,\n    dieOnTimeout: false,\n  },\n  unload: {\n    millis: 3000,\n    dieOnTimeout: false,\n  },\n};\n\nexport function setBootstrapMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`bootstrap max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.bootstrap = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function setMountMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`mount max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.mount = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function setUnmountMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`unmount max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.unmount = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function setUnloadMaxTime(time, dieOnTimeout = false) {\n  if (typeof time !== 'number' || time <= 0) {\n    throw Error(`unload max time must be a positive integer number of milliseconds`);\n  }\n\n  globalTimeoutConfig.unload = {\n    millis: time,\n    dieOnTimeout,\n  };\n}\n\nexport function reasonableTime(promise, description, timeoutConfig) {\n  const warningPeriod = 1000;\n\n  return new Promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n\n    promise\n    .then(val => {\n      finished = true;\n      resolve(val);\n    })\n    .catch(val => {\n      finished = true;\n      reject(val);\n    });\n\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n    function maybeTimingOut(shouldError) {\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n          if (timeoutConfig.dieOnTimeout) {\n            reject(`${description} did not resolve or reject for ${timeoutConfig.millis} milliseconds`);\n          } else {\n            console.error(`${description} did not resolve or reject for ${timeoutConfig.millis} milliseconds -- we're no longer going to warn you about it.`);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          const numWarnings = shouldError;\n          const numMillis = numWarnings * warningPeriod;\n          console.warn(`${description} did not resolve or reject within ${numMillis} milliseconds`);\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\n\nexport function ensureValidAppTimeouts(timeouts = {}) {\n  return {\n    ...globalTimeoutConfig,\n    ...timeouts,\n  }\n}\n","/* the array.prototype.find polyfill on npmjs.com is ~20kb (not worth it)\n * and lodash is ~200kb (not worth it)\n */\n\nexport function find(arr, func) {\n  for (let i=0; i<arr.length; i++) {\n    if (func(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n","import { find } from '../utils/find.js';\n\nexport function validLifecycleFn(fn) {\n  return fn && (typeof fn === 'function' || isArrayOfFns(fn));\n\n  function isArrayOfFns(arr) {\n    return Array.isArray(arr) && !find(arr, item => typeof item !== 'function');\n  }\n}\n\nexport function flattenFnArray(fns, description) {\n  fns = Array.isArray(fns) ? fns : [fns];\n  if (fns.length === 0) {\n    fns = [() => Promise.resolve()];\n  }\n\n  return function(props) {\n    return new Promise((resolve, reject) => {\n      waitForPromises(0);\n\n      function waitForPromises(index) {\n        const promise = fns[index](props);\n        if (!smellsLikeAPromise(promise)) {\n          reject(`${description} at index ${index} did not return a promise`);\n        } else {\n          promise\n            .then(() => {\n              if (index === fns.length - 1) {\n                resolve();\n              } else {\n                waitForPromises(index + 1);\n              }\n            })\n            .catch(reject);\n        }\n      }\n    });\n  }\n}\n\nexport function smellsLikeAPromise(promise) {\n  return promise && typeof promise.then === 'function' && typeof promise.catch === 'function';\n}\n","import { NOT_BOOTSTRAPPED, BOOTSTRAPPING, NOT_MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { handleAppError, transformErr } from '../applications/app-errors.js';\nimport { getProps } from './prop.helpers.js'\n\nexport function toBootstrapPromise(appOrParcel, hardFail = false) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_BOOTSTRAPPED) {\n      return appOrParcel;\n    }\n\n    appOrParcel.status = BOOTSTRAPPING;\n\n    return reasonableTime(appOrParcel.bootstrap(getProps(appOrParcel)), `Bootstrapping appOrParcel '${appOrParcel.name}'`, appOrParcel.timeouts.bootstrap)\n      .then(() => {\n        appOrParcel.status = NOT_MOUNTED;\n        return appOrParcel;\n      })\n      .catch(err => {\n        appOrParcel.status = SKIP_BECAUSE_BROKEN;\n        if (hardFail) {\n          const transformedErr = transformErr(err, appOrParcel)\n          throw transformedErr\n        } else {\n          handleAppError(err, appOrParcel);\n          return appOrParcel;\n        }\n      })\n  })\n}\n","import { UNMOUNTING, NOT_MOUNTED, MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { handleAppError, transformErr } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { getProps } from './prop.helpers.js';\n\nexport function toUnmountPromise(appOrParcel, hardFail = false) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== MOUNTED) {\n      return appOrParcel;\n    }\n    appOrParcel.status = UNMOUNTING;\n\n    const unmountChildrenParcels = Object.keys(appOrParcel.parcels)\n      .map(parcelId => appOrParcel.parcels[parcelId].unmountThisParcel());\n\n    let parcelError;\n\n    return Promise.all(unmountChildrenParcels)\n      .then(\n        unmountAppOrParcel,\n        parcelError => {\n          // There is a parcel unmount error\n          return unmountAppOrParcel()\n            .then(() => {\n              // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n              const parentError = Error(parcelError.message)\n              if (hardFail) {\n                const transformedErr = transformErr(parentError, appOrParcel)\n                appOrParcel.status = SKIP_BECAUSE_BROKEN;\n                throw transformedErr\n              } else {\n                handleAppError(parentError, appOrParcel);\n                appOrParcel.status = SKIP_BECAUSE_BROKEN;\n              }\n            })\n        }\n      )\n      .then(() => appOrParcel)\n\n    function unmountAppOrParcel() {\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      return reasonableTime(appOrParcel.unmount(getProps(appOrParcel)), `Unmounting application ${appOrParcel.name}'`, appOrParcel.timeouts.unmount)\n        .then(() => {\n          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelError) {\n            appOrParcel.status = NOT_MOUNTED;\n          }\n        })\n        .catch(err => {\n          if (hardFail) {\n            const transformedErr = transformErr(err, appOrParcel);\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n            throw transformedErr;\n          } else {\n            handleAppError(err, appOrParcel);\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n          }\n        })\n    }\n  })\n}\n","import { NOT_MOUNTED, MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { handleAppError, transformErr } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport CustomEvent from 'custom-event';\nimport { getProps } from './prop.helpers.js';\nimport { toUnmountPromise } from './unmount.js';\n\nlet beforeFirstMountFired = false;\nlet firstMountFired = false;\n\nexport function toMountPromise(appOrParcel, hardFail = false) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_MOUNTED) {\n      return appOrParcel;\n    }\n\n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new CustomEvent('single-spa:before-first-mount'));\n      beforeFirstMountFired = true;\n    }\n\n    return reasonableTime(appOrParcel.mount(getProps(appOrParcel)), `Mounting application '${appOrParcel.name}'`, appOrParcel.timeouts.mount)\n      .then(() => {\n        appOrParcel.status = MOUNTED;\n\n        if (!firstMountFired) {\n          window.dispatchEvent(new CustomEvent('single-spa:first-mount'));\n          firstMountFired = true;\n        }\n\n        return appOrParcel;\n      })\n      .catch(err => {\n        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        appOrParcel.status = MOUNTED\n        return toUnmountPromise(appOrParcel)\n          .then(setSkipBecauseBroken, setSkipBecauseBroken)\n\n        function setSkipBecauseBroken() {\n          if (!hardFail) {\n            handleAppError(err, appOrParcel);\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n            return appOrParcel;\n          } else {\n            const transformedErr = transformErr(err, appOrParcel)\n            appOrParcel.status = SKIP_BECAUSE_BROKEN;\n            throw transformedErr\n          }\n        }\n      })\n  })\n}\n","import { validLifecycleFn, flattenFnArray } from '../lifecycles/lifecycle.helpers.js';\nimport { NOT_BOOTSTRAPPED, NOT_MOUNTED, MOUNTED, UPDATING, LOADING_SOURCE_CODE, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { toBootstrapPromise } from '../lifecycles/bootstrap.js';\nimport { toMountPromise } from '../lifecycles/mount.js';\nimport { toUpdatePromise } from '../lifecycles/update.js';\nimport { toUnmountPromise } from '../lifecycles/unmount.js';\nimport { ensureValidAppTimeouts } from '../applications/timeouts.js';\n\nlet parcelCount = 0;\nconst rootParcels = {parcels: {}};\n\n// This is a public api, exported to users of single-spa\nexport function mountRootParcel() {\n  return mountParcel.apply(rootParcels, arguments);\n}\n\nexport function mountParcel(config, customProps) {\n  const owningAppOrParcel = this;\n\n  // Validate inputs\n  if (!config || (typeof config !== 'object' && typeof config !== 'function')) {\n    throw Error('Cannot mount parcel without a config object or config loading function');\n  }\n\n  if (config.name && typeof config.name !== 'string') {\n    throw Error('Parcel name must be a string, if provided');\n  }\n\n  if (typeof customProps !== 'object') {\n    throw Error(`Parcel ${name} has invalid customProps -- must be an object`);\n  }\n\n  if (!customProps.domElement) {\n    throw Error(`Parcel ${name} cannot be mounted without a domElement provided as a prop`);\n  }\n\n  const id = parcelCount++;\n\n  const passedConfigLoadingFunction = typeof config === 'function'\n  const configLoadingFunction = passedConfigLoadingFunction ? config : () => Promise.resolve(config)\n\n  // Internal representation\n  const parcel = {\n    id,\n    parcels: {},\n    status: passedConfigLoadingFunction ? LOADING_SOURCE_CODE : NOT_BOOTSTRAPPED,\n    customProps,\n    parentName: owningAppOrParcel.name,\n    unmountThisParcel() {\n      if (parcel.status !== MOUNTED) {\n        throw Error(`Cannot unmount parcel '${name}' -- it is in a ${parcel.status} status`);\n      }\n\n      return toUnmountPromise(parcel, true)\n        .then(value => {\n          if (parcel.parentName) {\n            delete owningAppOrParcel.parcels[parcel.id];\n          }\n\n          return value;\n        })\n        .then(value => {\n          resolveUnmount(value);\n          return value;\n        })\n        .catch(err => {\n          parcel.status = SKIP_BECAUSE_BROKEN;\n          rejectUnmount(err);\n          throw err;\n        });\n    }\n  };\n\n  // We return an external representation\n  let externalRepresentation\n\n  // Add to owning app or parcel\n  owningAppOrParcel.parcels[id] = parcel;\n\n  let loadPromise = configLoadingFunction()\n\n  if (!loadPromise || typeof loadPromise.then !== 'function') {\n    throw Error(`When mounting a parcel, the config loading function must return a promise that resolves with the parcel config`)\n  }\n\n  loadPromise = loadPromise.then(config => {\n    if (!config) {\n      throw Error(`When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config`)\n    }\n\n    const name = config.name || `parcel-${id}`;\n\n    if (!validLifecycleFn(config.bootstrap)) {\n      throw Error(`Parcel ${name} must have a valid bootstrap function`);\n    }\n\n    if (!validLifecycleFn(config.mount)) {\n      throw Error(`Parcel ${name} must have a valid mount function`);\n    }\n\n    if (!validLifecycleFn(config.unmount)) {\n      throw Error(`Parcel ${name} must have a valid unmount function`);\n    }\n\n    if (config.update && !validLifecycleFn(config.update)) {\n      throw Error(`Parcel ${name} provided an invalid update function`);\n    }\n\n    const bootstrap = flattenFnArray(config.bootstrap);\n    const mount = flattenFnArray(config.mount);\n    const unmount = flattenFnArray(config.unmount);\n\n    parcel.status = NOT_BOOTSTRAPPED;\n    parcel.name = name;\n    parcel.bootstrap = bootstrap;\n    parcel.mount = mount;\n    parcel.unmount = unmount;\n    parcel.timeouts = ensureValidAppTimeouts(config.timeouts);\n\n    if (config.update) {\n      parcel.update = flattenFnArray(config.update);\n      externalRepresentation.update = function(customProps) {\n        parcel.customProps = customProps;\n\n        return promiseWithoutReturnValue(toUpdatePromise(parcel));\n      }\n    }\n  })\n\n  // Start bootstrapping and mounting\n  // The .then() causes the work to be put on the event loop instead of happening immediately\n  const bootstrapPromise = loadPromise.then(() => toBootstrapPromise(parcel, true));\n  const mountPromise = bootstrapPromise.then(() => toMountPromise(parcel, true));\n\n  let resolveUnmount, rejectUnmount;\n\n  const unmountPromise = new Promise((resolve, reject) => {\n    resolveUnmount = resolve;\n    rejectUnmount = reject;\n  });\n\n  externalRepresentation = {\n    mount() {\n      return promiseWithoutReturnValue(\n        Promise\n        .resolve()\n        .then(() => {\n          if (parcel.status !== NOT_MOUNTED) {\n            throw Error(`Cannot mount parcel '${name}' -- it is in a ${parcel.status} status`);\n          }\n\n          // Add to owning app or parcel\n          owningAppOrParcel.parcels[id] = parcel;\n\n          return toMountPromise(parcel);\n        })\n      )\n    },\n    unmount() {\n      return promiseWithoutReturnValue(\n        parcel.unmountThisParcel()\n      );\n    },\n    getStatus() {\n      return parcel.status;\n    },\n    loadPromise: promiseWithoutReturnValue(loadPromise),\n    bootstrapPromise: promiseWithoutReturnValue(bootstrapPromise),\n    mountPromise: promiseWithoutReturnValue(mountPromise),\n    unmountPromise: promiseWithoutReturnValue(unmountPromise),\n  };\n\n  return externalRepresentation\n}\n\nfunction promiseWithoutReturnValue(promise) {\n  return promise.then(() => null);\n}\n","import { UPDATING, MOUNTED, SKIP_BECAUSE_BROKEN } from '../applications/app.helpers.js';\nimport { transformErr } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { getProps } from './prop.helpers.js';\n\nexport function toUpdatePromise(parcel) {\n  return Promise.resolve().then(() => {\n    if (parcel.status !== MOUNTED) {\n      throw Error(`Cannot update parcel '${parcel.name}' because it is not mounted`)\n    }\n\n    parcel.status = UPDATING;\n\n    return reasonableTime(parcel.update(getProps(parcel)), `Updating parcel '${parcel.name}'`, parcel.timeouts.mount)\n      .then(() => {\n        parcel.status = MOUNTED;\n        return parcel;\n      })\n      .catch(err => {\n        const transformedErr = transformErr(err, parcel)\n        parcel.status = SKIP_BECAUSE_BROKEN;\n        throw transformedErr;\n      })\n  })\n}\n\n","import * as singleSpa from '../single-spa.js'\nimport { mountParcel } from '../parcels/mount-parcel.js';\n\nexport function getProps(appOrParcel) {\n  const result = {\n    ...appOrParcel.customProps,\n    name: appOrParcel.name,\n    mountParcel: mountParcel.bind(appOrParcel),\n    singleSpa\n  };\n\n  if (appOrParcel.unmountThisParcel) {\n    result.unmountSelf = appOrParcel.unmountThisParcel;\n  }\n\n  return result;\n}\n","import { NOT_BOOTSTRAPPED, LOADING_SOURCE_CODE, SKIP_BECAUSE_BROKEN, NOT_LOADED } from '../applications/app.helpers.js';\nimport { ensureValidAppTimeouts } from '../applications/timeouts.js';\nimport { handleAppError } from '../applications/app-errors.js';\nimport { flattenFnArray, smellsLikeAPromise, validLifecycleFn } from './lifecycle.helpers.js';\nimport { getProps } from './prop.helpers.js';\n\nexport function toLoadPromise(app) {\n  return Promise.resolve().then(() => {\n    if (app.status !== NOT_LOADED) {\n      return app;\n    }\n\n    app.status = LOADING_SOURCE_CODE;\n\n    let appOpts;\n\n    return Promise.resolve().then(() => {\n      const loadPromise = app.loadImpl(getProps(app));\n      if (!smellsLikeAPromise(loadPromise)) {\n        // The name of the app will be prepended to this error message inside of the handleAppError function\n        throw Error(`single-spa loading function did not return a promise. Check the second argument to registerApplication('${app.name}', loadingFunction, activityFunction)`);\n      }\n      return loadPromise.then(val => {\n        appOpts = val;\n\n        let validationErrMessage;\n\n        if (typeof appOpts !== 'object') {\n          validationErrMessage = `does not export anything`;\n        }\n\n        if (!validLifecycleFn(appOpts.bootstrap)) {\n          validationErrMessage = `does not export a bootstrap function or array of functions`;\n        }\n\n        if (!validLifecycleFn(appOpts.mount)) {\n          validationErrMessage = `does not export a mount function or array of functions`;\n        }\n\n        if (!validLifecycleFn(appOpts.unmount)) {\n          validationErrMessage = `does not export an unmount function or array of functions`;\n        }\n\n        if (validationErrMessage) {\n          handleAppError(validationErrMessage, app);\n          app.status = SKIP_BECAUSE_BROKEN;\n          return app;\n        }\n\n        if (appOpts.devtools && appOpts.devtools.overlays) {\n          app.devtools.overlays = {...app.devtools.overlays, ...appOpts.devtools.overlays}\n        }\n\n        app.status = NOT_BOOTSTRAPPED;\n        app.bootstrap = flattenFnArray(appOpts.bootstrap, `App '${app.name}' bootstrap function`);\n        app.mount = flattenFnArray(appOpts.mount, `App '${app.name}' mount function`);\n        app.unmount = flattenFnArray(appOpts.unmount, `App '${app.name}' unmount function`);\n        app.unload = flattenFnArray(appOpts.unload || [], `App '${app.name}' unload function`);\n        app.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n\n        return app;\n      })\n    })\n    .catch(err => {\n      handleAppError(err, app);\n      app.status = SKIP_BECAUSE_BROKEN;\n      return app;\n    })\n  })\n}\n","import { reroute } from './reroute.js';\nimport { find } from '../utils/find.js';\n\n/* We capture navigation event listeners so that we can make sure\n * that application navigation listeners are not called until\n * single-spa has ensured that the correct applications are\n * unmounted and mounted.\n */\nconst capturedEventListeners = {\n  hashchange: [],\n  popstate: [],\n};\n\nexport const routingEventsListeningTo = ['hashchange', 'popstate'];\n\nexport function navigateToUrl(obj, opts={}) {\n  let url;\n  if (typeof obj === 'string') {\n    url = obj ;\n  } else if (this && this.href) {\n    url = this.href;\n  } else if (obj && obj.currentTarget && obj.currentTarget.href && obj.preventDefault) {\n    url = obj.currentTarget.href;\n    obj.preventDefault();\n  } else {\n    throw Error(`singleSpaNavigate must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`);\n  }\n\n  const current = parseUri(window.location.href);\n  const destination = parseUri(url);\n\n  if (url.indexOf('#') === 0) {\n    window.location.hash = '#' + destination.anchor;\n  } else if (current.host !== destination.host && destination.host) {\n    if (opts.isTestingEnv) {\n      return {wouldHaveReloadedThePage: true};\n    } else {\n      window.location.href = url;\n    }\n  } else if (!isSamePath(destination.path, current.path)) {\n    // different path or a different host\n    window.history.pushState(null, null, url);\n  } else {\n    window.location.hash = '#' + destination.anchor;\n  }\n\n  function isSamePath(destination, current) {\n    // if the destination has a path but no domain, it doesn't include the root '/'\n    return current === destination || current === '/' + destination;\n  }\n}\n\nexport function callCapturedEventListeners(eventArguments) {\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      capturedEventListeners[eventType].forEach(listener => {\n        listener.apply(this, eventArguments);\n      });\n    }\n  }\n}\n\nfunction urlReroute() {\n  reroute([], arguments)\n}\n\n\n// We will trigger an app change for any routing events.\nwindow.addEventListener('hashchange', urlReroute);\nwindow.addEventListener('popstate', urlReroute);\n\n// Monkeypatch addEventListener so that we can ensure correct timing\nconst originalAddEventListener = window.addEventListener;\nconst originalRemoveEventListener = window.removeEventListener;\nwindow.addEventListener = function(eventName, fn) {\n  if (typeof fn === 'function') {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0 && !find(capturedEventListeners[eventName], listener => listener === fn)) {\n      capturedEventListeners[eventName].push(fn);\n      return;\n    }\n  }\n\n  return originalAddEventListener.apply(this, arguments);\n}\n\nwindow.removeEventListener = function(eventName, listenerFn) {\n  if (typeof listenerFn === 'function') {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n      capturedEventListeners[eventName] = capturedEventListeners[eventName].filter(fn => fn !== listenerFn);\n      return;\n    }\n  }\n\n  return originalRemoveEventListener.apply(this, arguments);\n}\n\nconst originalPushState = window.history.pushState;\nwindow.history.pushState = function(state) {\n  const result = originalPushState.apply(this, arguments);\n\n  urlReroute(createPopStateEvent(state));\n  \n  return result;\n}\n\nconst originalReplaceState = window.history.replaceState;\nwindow.history.replaceState = function(state) {\n  const result = originalReplaceState.apply(this, arguments);\n  urlReroute(createPopStateEvent(state));\n  return result;\n}\n\nfunction createPopStateEvent(state) {\n  // https://github.com/CanopyTax/single-spa/issues/224 and https://github.com/CanopyTax/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn't do one by default when you call replaceState, so that\n  // all the applications can reroute.\n  try {\n    return new PopStateEvent('popstate', {state});\n  } catch (err) {\n    // IE 11 compatibility https://github.com/CanopyTax/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    const evt = document.createEvent('PopStateEvent');\n    evt.initPopStateEvent('popstate', false, false, state);\n    return evt;\n  }\n}\n\n/* For convenience in `onclick` attributes, we expose a global function for navigating to\n * whatever an <a> tag's href is.\n */\nwindow.singleSpaNavigate = navigateToUrl;\n\nfunction parseUri(str) {\n  // parseUri 1.2.2\n  // (c) Steven Levithan <stevenlevithan.com>\n  // MIT License\n  // http://blog.stevenlevithan.com/archives/parseuri\n  const parseOptions = {\n    strictMode: true,\n    key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n    q:   {\n      name:   \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  };\n\n  let  o = parseOptions;\n  let m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n  let uri = {};\n  let i = 14;\n\n  while (i--) uri[o.key[i]] = m[i] || \"\";\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) uri[o.q.name][$1] = $2;\n  });\n\n  return uri;\n}\n","import { routingEventsListeningTo } from './navigation/navigation-events.js';\n\nlet hasInitialized = false;\n\nexport function ensureJQuerySupport(jQuery = window.jQuery) {\n  if (!jQuery) {\n    if (window.$ && window.$.fn && window.$.fn.jquery) {\n      jQuery = window.$;\n    }\n  }\n\n  if (jQuery && !hasInitialized) {\n    const originalJQueryOn = jQuery.fn.on;\n    const originalJQueryOff = jQuery.fn.off;\n\n    jQuery.fn.on = function(eventString, fn) {\n      return captureRoutingEvents.call(this, originalJQueryOn, window.addEventListener, eventString, fn, arguments);\n    }\n\n    jQuery.fn.off = function(eventString, fn) {\n      return captureRoutingEvents.call(this, originalJQueryOff, window.removeEventListener, eventString, fn, arguments);\n    }\n\n    hasInitialized = true;\n  }\n}\n\nfunction captureRoutingEvents(originalJQueryFunction, nativeFunctionToCall, eventString, fn, originalArgs) {\n  if (typeof eventString !== 'string') {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n\n  const eventNames = eventString.split(/\\s+/);\n  eventNames.forEach(eventName => {\n    if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n      nativeFunctionToCall(eventName, fn);\n      eventString = eventString.replace(eventName, '');\n    }\n  });\n\n  if (eventString.trim() === '') {\n    return this;\n  } else {\n    return originalJQueryFunction.apply(this, originalArgs);\n  }\n}\n","import { NOT_MOUNTED, UNLOADING, NOT_LOADED, SKIP_BECAUSE_BROKEN, isntActive } from '../applications/app.helpers.js';\nimport { handleAppError } from '../applications/app-errors.js';\nimport { reasonableTime } from '../applications/timeouts.js';\nimport { getProps } from './prop.helpers.js';\n\nconst appsToUnload = {};\n\nexport function toUnloadPromise(app) {\n  return Promise.resolve().then(() => {\n    const unloadInfo = appsToUnload[app.name];\n\n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n      */\n      return app;\n    }\n\n    if (app.status === NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(app, unloadInfo);\n      return app;\n    }\n\n    if (app.status === UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      return unloadInfo.promise.then(() => app);\n    }\n\n    if (app.status !== NOT_MOUNTED) {\n      /* The app cannot be unloaded until it is unmounted.\n      */\n      return app;\n    }\n\n    app.status = UNLOADING;\n    return reasonableTime(app.unload(getProps(app)), `Unloading application '${app.name}'`, app.timeouts.unload)\n      .then(() => {\n        finishUnloadingApp(app, unloadInfo);\n        return app;\n      })\n      .catch(err => {\n        errorUnloadingApp(app, unloadInfo, err);\n        return app;\n      })\n  })\n}\n\nfunction finishUnloadingApp(app, unloadInfo) {\n  delete appsToUnload[app.name];\n\n  // Unloaded apps don't have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  app.status = NOT_LOADED;\n\n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app, unloadInfo, err) {\n  delete appsToUnload[app.name];\n\n  // Unloaded apps don't have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleAppError(err, app);\n  app.status = SKIP_BECAUSE_BROKEN;\n  unloadInfo.reject(err);\n}\n\nexport function addAppToUnload(app, promiseGetter, resolve, reject) {\n  appsToUnload[app.name] = {app, resolve, reject};\n  Object.defineProperty(appsToUnload[app.name], 'promise', {get: promiseGetter});\n}\n\nexport function getAppUnloadInfo(appName) {\n  return appsToUnload[appName];\n}\n\nexport function getAppsToUnload() {\n  return Object.keys(appsToUnload)\n    .map(appName => appsToUnload[appName].app)\n    .filter(isntActive)\n}\n","import { ensureJQuerySupport } from '../jquery-support.js';\nimport { isActive, isLoaded, isntLoaded, toName, NOT_LOADED, shouldBeActive, shouldntBeActive, isntActive, notSkipped } from './app.helpers.js';\nimport { reroute } from '../navigation/reroute.js';\nimport { find } from '../utils/find.js';\nimport { toUnmountPromise } from '../lifecycles/unmount.js';\nimport { toUnloadPromise, getAppUnloadInfo, addAppToUnload } from '../lifecycles/unload.js';\n\nconst apps = [];\n\nexport function getMountedApps() {\n  return apps.filter(isActive).map(toName);\n}\n\nexport function getAppNames() {\n  return apps.map(toName);\n}\n\n// used in devtools, not (currently) exposed as a single-spa API\nexport function getRawAppData() {\n  return [...apps];\n}\n\nexport function getAppStatus(appName) {\n  const app = find(apps, app => app.name === appName);\n  return app ? app.status : null;\n}\n\nexport function declareChildApplication(appName, arg1, arg2) {\n  console.warn('declareChildApplication is deprecated and will be removed in the next major version, use \"registerApplication\" instead')\n  return registerApplication(appName, arg1, arg2)\n}\n\nexport function registerApplication(appName, applicationOrLoadingFn, activityFn, customProps = {}) {\n  if (typeof appName !== 'string' || appName.length === 0)\n    throw Error(`The first argument must be a non-empty string 'appName'`);\n  if (getAppNames().indexOf(appName) !== -1)\n    throw Error(`There is already an app declared with name ${appName}`);\n  if (typeof customProps !== 'object' || Array.isArray(customProps))\n    throw Error('customProps must be an object');\n\n  if (!applicationOrLoadingFn)\n    throw Error(`The application or loading function is required`);\n\n  let loadImpl;\n  if (typeof applicationOrLoadingFn !== 'function') {\n    // applicationOrLoadingFn is an application\n    loadImpl = () => Promise.resolve(applicationOrLoadingFn);\n  } else {\n    // applicationOrLoadingFn is a loadingFn\n    loadImpl = applicationOrLoadingFn;\n  }\n\n  if (typeof activityFn !== 'function')\n    throw Error(`The activeWhen argument must be a function`);\n\n  apps.push({\n    name: appName,\n    loadImpl,\n    activeWhen: activityFn,\n    status: NOT_LOADED,\n    parcels: {},\n    devtools: {\n      overlays: {\n        options: {},\n        selectors: [],\n      }\n    },\n    customProps\n  });\n\n  ensureJQuerySupport();\n\n  reroute();\n}\n\nexport function checkActivityFunctions(location) {\n  const activeApps = []\n  for (let i = 0; i < apps.length; i++) {\n    if (apps[i].activeWhen(location)) {\n      activeApps.push(apps[i].name)\n    }\n  }\n  return activeApps\n}\n\nexport function getAppsToLoad() {\n  return apps\n    .filter(notSkipped)\n    .filter(isntLoaded)\n    .filter(shouldBeActive)\n}\n\nexport function getAppsToUnmount() {\n  return apps\n    .filter(notSkipped)\n    .filter(isActive)\n    .filter(shouldntBeActive)\n}\n\nexport function getAppsToMount() {\n  return apps\n    .filter(notSkipped)\n    .filter(isntActive)\n    .filter(isLoaded)\n    .filter(shouldBeActive)\n}\n\nexport function unregisterApplication(appName) {\n  if (!apps.find(app => app.name === appName)) {\n    throw Error(`Cannot unregister application '${appName}' because no such application has been registered`)\n  }\n\n  return unloadApplication(appName)\n    .then(() => {\n      const appIndex = apps.findIndex(app => app.name === appName)\n      apps.splice(appIndex, 1)\n    })\n}\n\nexport function unloadChildApplication(appName, opts) {\n  console.warn('unloadChildApplication is deprecated and will be removed in the next major version, use \"unloadApplication\" instead')\n  return unloadApplication(appName, opts)\n}\n\nexport function unloadApplication(appName, opts={waitForUnmount: false}) {\n  if (typeof appName !== 'string') {\n    throw Error(`unloadApplication requires a string 'appName'`);\n  }\n  const app = find(apps, App => App.name === appName);\n  if (!app) {\n    throw Error(`Could not unload application '${appName}' because no such application has been registered`);\n  }\n\n  const appUnloadInfo = getAppUnloadInfo(app.name);\n  if (opts && opts.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      return appUnloadInfo.promise;\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      const promise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.\n     */\n\n    let resultPromise;\n\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n\n    return resultPromise;\n  }\n}\n\nfunction immediatelyUnloadApp(app, resolve, reject) {\n  toUnmountPromise(app)\n    .then(toUnloadPromise)\n    .then(() => {\n      resolve()\n      setTimeout(() => {\n        // reroute, but the unload promise is done\n        reroute()\n      });\n    })\n    .catch(reject);\n}\n","import CustomEvent from 'custom-event';\nimport { isStarted } from '../start.js';\nimport { toLoadPromise } from '../lifecycles/load.js';\nimport { toBootstrapPromise } from '../lifecycles/bootstrap.js';\nimport { toMountPromise } from '../lifecycles/mount.js';\nimport { toUnmountPromise } from '../lifecycles/unmount.js';\nimport { getMountedApps, getAppsToLoad, getAppsToUnmount, getAppsToMount } from '../applications/apps.js';\nimport { callCapturedEventListeners } from './navigation-events.js';\nimport { getAppsToUnload, toUnloadPromise } from '../lifecycles/unload.js';\n\nlet appChangeUnderway = false, peopleWaitingOnAppChange = [];\n\nexport function triggerAppChange() {\n  // Call reroute with no arguments, intentionally\n  return reroute()\n}\n\nexport function reroute(pendingPromises = [], eventArguments) {\n  if (appChangeUnderway) {\n    return new Promise((resolve, reject) => {\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n\n  appChangeUnderway = true;\n  let wasNoOp = true;\n\n  if (isStarted()) {\n    return performAppChanges();\n  } else {\n    return loadApps();\n  }\n\n  function loadApps() {\n    return Promise.resolve().then(() => {\n      const loadPromises = getAppsToLoad().map(toLoadPromise);\n\n      if (loadPromises.length > 0) {\n        wasNoOp = false;\n      }\n\n      return Promise\n        .all(loadPromises)\n        .then(finishUpAndReturn)\n        .catch(err => {\n          callAllEventListeners();\n          throw err;\n        })\n    })\n  }\n\n  function performAppChanges() {\n    return Promise.resolve().then(() => {\n      window.dispatchEvent(new CustomEvent(\"single-spa:before-routing-event\", getCustomEventDetail()));\n      const unloadPromises = getAppsToUnload().map(toUnloadPromise);\n\n      const unmountUnloadPromises = getAppsToUnmount()\n        .map(toUnmountPromise)\n        .map(unmountPromise => unmountPromise.then(toUnloadPromise));\n\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      if (allUnmountPromises.length > 0) {\n        wasNoOp = false;\n      }\n\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n\n      const appsToLoad = getAppsToLoad();\n\n      /* We load and bootstrap apps while other apps are unmounting, but we\n       * wait to mount the app until all apps are finishing unmounting\n       */\n      const loadThenMountPromises = appsToLoad.map(app => {\n        return toLoadPromise(app)\n          .then(toBootstrapPromise)\n          .then(app => {\n            return unmountAllPromise\n              .then(() => toMountPromise(app))\n          })\n      })\n      if (loadThenMountPromises.length > 0) {\n        wasNoOp = false;\n      }\n\n      /* These are the apps that are already bootstrapped and just need\n       * to be mounted. They each wait for all unmounting apps to finish up\n       * before they mount.\n       */\n      const mountPromises = getAppsToMount()\n        .filter(appToMount => appsToLoad.indexOf(appToMount) < 0)\n        .map(appToMount => {\n          return toBootstrapPromise(appToMount)\n            .then(() => unmountAllPromise)\n            .then(() => toMountPromise(appToMount))\n        })\n      if (mountPromises.length > 0) {\n        wasNoOp = false;\n      }\n      return unmountAllPromise\n        .catch(err => {\n          callAllEventListeners();\n          throw err;\n        })\n        .then(() => {\n          /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n           * events (like hashchange or popstate) should have been cleaned up. So it's safe\n           * to let the remaining captured event listeners to handle about the DOM event.\n           */\n          callAllEventListeners();\n\n          return Promise\n            .all(loadThenMountPromises.concat(mountPromises))\n            .catch(err => {\n              pendingPromises.forEach(promise => promise.reject(err));\n              throw err;\n            })\n            .then(() => finishUpAndReturn(false))\n        })\n\n    })\n  }\n\n  function finishUpAndReturn(callEventListeners=true) {\n    const returnValue = getMountedApps();\n\n    if (callEventListeners) {\n      callAllEventListeners();\n    }\n    pendingPromises.forEach(promise => promise.resolve(returnValue));\n\n    try {\n      const appChangeEventName = wasNoOp ? \"single-spa:no-app-change\": \"single-spa:app-change\";\n      window.dispatchEvent(new CustomEvent(appChangeEventName, getCustomEventDetail()));\n      window.dispatchEvent(new CustomEvent(\"single-spa:routing-event\", getCustomEventDetail()));\n    } catch (err) {\n      /* We use a setTimeout because if someone else's event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it's their own fault, not\n       * single-spa's.\n       */\n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    appChangeUnderway = false;\n\n    if (peopleWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      const nextPendingPromises = peopleWaitingOnAppChange;\n      peopleWaitingOnAppChange = [];\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n\n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  function callAllEventListeners() {\n    pendingPromises.forEach(pendingPromise => {\n      callCapturedEventListeners(pendingPromise.eventArguments);\n    });\n\n    callCapturedEventListeners(eventArguments);\n  }\n\n  function getCustomEventDetail() {\n    const result = {detail: {}}\n\n    if (eventArguments && eventArguments[0]) {\n      result.detail.originalEvent = eventArguments[0]\n    }\n\n    return result\n  }\n}\n","import { reroute } from './navigation/reroute.js';\n\nlet started = false;\n\nexport function start() {\n  started = true;\n  reroute();\n}\n\nexport function isStarted() {\n  return started;\n}\n\nconst startWarningDelay = 5000;\n\nsetTimeout(() => {\n  if (!started) {\n    console.warn(`singleSpa.start() has not been called, ${startWarningDelay}ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted. See https://github.com/CanopyTax/single-spa/blob/master/docs/single-spa-api.md#start`);\n  }\n}, startWarningDelay)\n","import {getRawAppData, unregisterApplication} from '../applications/apps'\nimport {reroute} from '../navigation/reroute'\nimport {NOT_LOADED} from '../applications/app.helpers'\nimport {toLoadPromise} from '../lifecycles/load'\nimport {toBootstrapPromise} from '../lifecycles/bootstrap'\n\nexport default {\n  getRawAppData,\n  reroute,\n  NOT_LOADED,\n  toLoadPromise,\n  toBootstrapPromise,\n  unregisterApplication,\n}\n","export { start } from './start.js';\nexport { ensureJQuerySupport } from './jquery-support.js';\nexport { setBootstrapMaxTime, setMountMaxTime, setUnmountMaxTime, setUnloadMaxTime } from './applications/timeouts.js';\nexport { registerApplication, getMountedApps, getAppStatus, unloadApplication, checkActivityFunctions, getAppNames, declareChildApplication, unloadChildApplication } from './applications/apps.js';\nexport { navigateToUrl } from './navigation/navigation-events.js';\nexport { triggerAppChange } from './navigation/reroute.js';\nexport { addErrorHandler, removeErrorHandler } from './applications/app-errors.js';\nexport { mountRootParcel } from './parcels/mount-parcel.js';\n\nexport {\n  NOT_LOADED,\n  LOADING_SOURCE_CODE,\n  NOT_BOOTSTRAPPED,\n  BOOTSTRAPPING,\n  NOT_MOUNTED,\n  MOUNTING,\n  UPDATING,\n  MOUNTED,\n  UNMOUNTING,\n  SKIP_BECAUSE_BROKEN,\n} from './applications/app.helpers.js';\n\nimport devtools from \"./devtools/devtools\"\nif(window && window.__SINGLE_SPA_DEVTOOLS__) {\n  window.__SINGLE_SPA_DEVTOOLS__.exposedMethods = devtools\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { registerApplication, start } from 'single-spa'\n\nregisterApplication(\n  // Name of our single-spa application\n  'home',\n  // loadingFunction\n  () => import('./src/home/home.app.js'),\n  // activityFunction\n  () => location.pathname === \"\" || \n    location.pathname === \"/\"\n);\nregisterApplication(\n  // Name of our single-spa application\n  'vue',\n  // loadingFunction\n  () => import('./src/vue/vue.app.js'),\n  // activityFunction\n  pathPrefix('/vue')\n);\nregisterApplication(\n  // Name of our single-spa application\n  'test',\n  // loadingFunction\n  () => import('./src/test/test.app.js'),\n  // activityFunction\n  pathPrefix('/test')\n);\nfunction pathPrefix(prefix) {\n  return function(location) {\n      return location.pathname.indexOf(`${prefix}`) === 0;\n  }\n}\n\nstart();\n\n"],"sourceRoot":""}